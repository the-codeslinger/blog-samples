package com.thecodeslinger.bcc;

import lombok.SneakyThrows;
import org.bouncycastle.asn1.oiw.OIWObjectIdentifiers;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x509.*;
import org.bouncycastle.cert.X509ExtensionUtils;
import org.bouncycastle.cert.X509v3CertificateBuilder;
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
import org.bouncycastle.operator.bc.BcDigestCalculatorProvider;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;

import java.math.BigInteger;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.SecureRandom;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.List;

import static org.bouncycastle.jce.provider.BouncyCastleProvider.PROVIDER_NAME;

public class CertificateFactory {

    private static final int ROOT_CA_CERT_LIFETIME_DAYS = 5;
    private static final int INTERMEDIATE_CA_CERT_LIFETIME_DAYS = 3;
    private static final int LEAF_CERT_LIFETIME_DAYS = 1;

    private static final int ROOT_CA_DEPTH = 2;
    private static final int INTERMEDIATE_CA_DEPTH = 1;

    private static final SecureRandom SECURE_RANDOM = new SecureRandom();

    @SneakyThrows
    public static KeyPairCertificate createSelfSignedCA(String distinguishedName) {
        return createCertificate(distinguishedName, ROOT_CA_DEPTH, ROOT_CA_CERT_LIFETIME_DAYS, null);
    }

    @SneakyThrows
    public static KeyPairCertificate createCA(String distinguishedName, KeyPairCertificate issuer) {
        return createCertificate(distinguishedName, INTERMEDIATE_CA_DEPTH, INTERMEDIATE_CA_CERT_LIFETIME_DAYS, issuer);
    }

    @SneakyThrows
    public static KeyPairCertificate createLeaf(String distinguishedName, KeyPairCertificate issuer) {
        return createCertificate(distinguishedName, 0, LEAF_CERT_LIFETIME_DAYS, issuer);
    }

    @SneakyThrows
    private static KeyPairCertificate createCertificate(String distinguishedName, int certChainDepth, int lifetime,
                                                        KeyPairCertificate issuer) {
        // No issuer = self-signed root CA.

        var keyPair = generateKeyPair("RSA");
        var publicKeyInfo = getPublicKeyInfo(keyPair);
        var issuerKeyInfo = getIssuerPublicKeyInfo(publicKeyInfo, issuer);

        var ownerName = new X500Name(distinguishedName);
        var issuerName = getIssuerX500Name(ownerName, issuer);

        var extensions = generateExtensions(publicKeyInfo, issuerKeyInfo, certChainDepth);

        var serialNumber = BigInteger.valueOf(Math.abs(SECURE_RANDOM.nextInt()));
        var validFrom = Date.from(Instant.now());
        var validTo = Date.from(Instant.now().plus(lifetime, ChronoUnit.DAYS));

        var certBuilder = new X509v3CertificateBuilder(
                issuerName, serialNumber,   // Usually generated by a CA.
                validFrom, validTo,         // Lifetime, also generated by a CA.
                ownerName, publicKeyInfo);  // Owner information.

        // Nicer than a lambda because of the exception handling.
        for (var extension : extensions) {
            certBuilder.addExtension(extension);
        }

        var issuerKeyPair = getIssuerKeyPair(keyPair, issuer);
        var contentSigner = new JcaContentSignerBuilder("SHA1WithRSAEncryption").setProvider(PROVIDER_NAME)
                .build(issuerKeyPair.getPrivate());

        var certConverter = new JcaX509CertificateConverter().setProvider(PROVIDER_NAME);
        var certificate = certConverter.getCertificate(certBuilder.build(contentSigner));

        return new KeyPairCertificate(keyPair, certificate);
    }

    @SneakyThrows
    private static KeyPair generateKeyPair(String algorithm) {
        var keyPairGen = KeyPairGenerator.getInstance(algorithm, PROVIDER_NAME);
        keyPairGen.initialize(2048, SECURE_RANDOM);
        return keyPairGen.generateKeyPair();
    }

    private static SubjectPublicKeyInfo getPublicKeyInfo(KeyPair keyPair) {
        return SubjectPublicKeyInfo.getInstance(keyPair.getPublic().getEncoded());
    }

    private static SubjectPublicKeyInfo getIssuerPublicKeyInfo(
            SubjectPublicKeyInfo ownerKeyInfo, KeyPairCertificate issuer) {

        if (null != issuer) {
            return getPublicKeyInfo(issuer.keyPair());
        } else {
            return ownerKeyInfo;
        }
    }

    private static X500Name getIssuerX500Name(X500Name ownerName, KeyPairCertificate issuer) {
        if (null != issuer) {
            return new X500Name(issuer.certificate().getSubjectX500Principal().getName());
        } else {
            return ownerName;
        }
    }

    private static KeyPair getIssuerKeyPair(KeyPair ownerKeyPair, KeyPairCertificate issuer) {
        if (null != issuer) {
            return issuer.keyPair();
        } else {
            return ownerKeyPair;
        }
    }

    @SneakyThrows
    private static List<Extension> generateExtensions(
            SubjectPublicKeyInfo ownerKeyInfo, SubjectPublicKeyInfo issuerKeyInfo, int certChainDepth) {
        // If cert chain depth is larger than zero then we're creating a CA.

        KeyUsage keyUsageExt;
        if (0 < certChainDepth) {
            keyUsageExt = new KeyUsage(KeyUsage.keyCertSign | KeyUsage.cRLSign);
        } else {
            keyUsageExt = new KeyUsage(KeyUsage.digitalSignature);
        }

        BasicConstraints basicConstraintsExt;
        if (0 < certChainDepth) {
            basicConstraintsExt = new BasicConstraints(certChainDepth);
        } else {
            basicConstraintsExt = new BasicConstraints(false);
        }

        // Need to use an SHA-1 based algorithm to conform to RFC-5280.
        var digestCalc = new BcDigestCalculatorProvider().get(new AlgorithmIdentifier(OIWObjectIdentifiers.idSHA1));
        var extensionUtils = new X509ExtensionUtils(digestCalc);
        var subjectKeyIdentifier = extensionUtils.createSubjectKeyIdentifier(ownerKeyInfo);
        var issuerKeyIdentifier = extensionUtils.createAuthorityKeyIdentifier(issuerKeyInfo);

        return List.of(
                Extension.create(Extension.keyUsage, false, keyUsageExt),
                Extension.create(Extension.basicConstraints, false, basicConstraintsExt),
                Extension.create(Extension.subjectKeyIdentifier, false, subjectKeyIdentifier),
                Extension.create(Extension.authorityKeyIdentifier, false, issuerKeyIdentifier));
    }
}
