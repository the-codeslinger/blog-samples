package com.thecodeslinger.bcc;

import lombok.SneakyThrows;
import org.bouncycastle.asn1.oiw.OIWObjectIdentifiers;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x509.*;
import org.bouncycastle.cert.X509ExtensionUtils;
import org.bouncycastle.cert.X509v3CertificateBuilder;
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openssl.jcajce.JcaPEMWriter;
import org.bouncycastle.operator.bc.BcDigestCalculatorProvider;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.SecureRandom;
import java.security.Security;
import java.security.cert.X509Certificate;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.List;

import static org.bouncycastle.jce.provider.BouncyCastleProvider.PROVIDER_NAME;


public class Main {

    @SneakyThrows
    public static void main(String[] args) {

        Security.addProvider(new BouncyCastleProvider());

        var random = new SecureRandom();

        // First: We need a key pair. The public key makes its way into the certificate,
        // and the private key must stay private.
        var keyPair = generateKeyPair("RSA", random);
        var publicKeyInfo = getPublicKeyInfo(keyPair);

        // Second: The Distinguished Name of the certificate owner.
        // Can be a URL, e.g., for TLS certificates, or a person's name, or...
        // This line is equivalent to: new X500Name(BCStyle.INSTANCE, "...");
        var certOwner = new X500Name("CN=the-codeslinger.com,C=DE");

        // I am using a self-signed certificate in this example, so the issuer is the same.
        var certIssuer = new X500Name("CN=the-codeslinger.com,C=DE");

        // Third: All the certificate extensions.
        var certificateExtensions = generateExtensions(publicKeyInfo);

        // Fourth: The certificate.
        var serialNumber = BigInteger.valueOf(Math.abs(random.nextInt()));
        var validFromNow = Date.from(Instant.now());
        var validToInAYear = Date.from(Instant.now().plus(365, ChronoUnit.DAYS));

        var certBuilder = new X509v3CertificateBuilder(
                certIssuer, serialNumber,     // Usually generated by a CA.
                validFromNow, validToInAYear, // Lifetime, also generated by a CA.
                certOwner, publicKeyInfo);    // Owner information.
        certificateExtensions.forEach(ext -> {
            try {
                certBuilder.addExtension(ext);
            } catch (Exception e) {
                // Ignore
            }
        });

        // Fifth: Create a signer that signs the certificate.
        // In this case, the certificate is self-signed, so the generated key is used.
        // If a CA signs the certificate, its key is used.
        var sigGen = new JcaContentSignerBuilder("SHA1WithRSAEncryption").setProvider(PROVIDER_NAME)
                .build(keyPair.getPrivate());

        // Lastly: Create the certificate.
        var certConverter = new JcaX509CertificateConverter().setProvider(PROVIDER_NAME);
        var certificate = certConverter.getCertificate(certBuilder.build(sigGen));

        writeAsPem(certificate);
        writeAsDer(certificate);
    }

    @SneakyThrows
    private static KeyPair generateKeyPair(String algorithm, SecureRandom random) {
        var keyPairGen = KeyPairGenerator.getInstance(algorithm, PROVIDER_NAME);
        keyPairGen.initialize(2048, random);
        return keyPairGen.generateKeyPair();
    }

    private static SubjectPublicKeyInfo getPublicKeyInfo(KeyPair keyPair) {
        return SubjectPublicKeyInfo.getInstance(keyPair.getPublic().getEncoded());
    }

    @SneakyThrows
    private static List<Extension> generateExtensions(SubjectPublicKeyInfo publicKeyInfo) {
        // Certificate will only be used for signing data.
        var keyUsageExt = new KeyUsage(KeyUsage.digitalSignature);

        var keyPurposeIds = new KeyPurposeId[]{KeyPurposeId.id_kp_clientAuth};
        var extendedKeyUsageExt = new ExtendedKeyUsage(keyPurposeIds);

        // Use this for a CA and set how long the cert-chain ca be: new BasicConstraints(1);
        // Setting false indicates this is a leaf, not a CA.
        var basicConstraintsExt = new BasicConstraints(false);

        // Need to use an SHA-1 based algorithm to conform to RFC-5280.
        var digestCalc = new BcDigestCalculatorProvider().get(new AlgorithmIdentifier(OIWObjectIdentifiers.idSHA1));
        var extensionUtils = new X509ExtensionUtils(digestCalc);
        var subjectKeyIdentifier = extensionUtils.createSubjectKeyIdentifier(publicKeyInfo);

        return List.of(
                Extension.create(Extension.keyUsage, false, keyUsageExt),
                Extension.create(Extension.extendedKeyUsage, false, extendedKeyUsageExt),
                Extension.create(Extension.basicConstraints, false, basicConstraintsExt),
                Extension.create(Extension.subjectKeyIdentifier, false, subjectKeyIdentifier));
    }

    @SneakyThrows
    private static void writeAsPem(X509Certificate certificate) {
        // Print as PEM.
        // Decode with: openssl x509 -text -noout -in cert.pem
        try (var pemWriter = new JcaPEMWriter(new PrintWriter(System.out))) {
            pemWriter.writeObject(certificate);
        }

        var pemFile = new File("/home/rlo/certificate.pem");
        try (var pemWriter = new JcaPEMWriter(new FileWriter(pemFile))) {
            pemWriter.writeObject(certificate);
        }
    }

    @SneakyThrows
    private static void writeAsDer(X509Certificate certificate) {
        var derFile = new File("/home/rlo/certificate.der");
        try (var writer = new FileOutputStream(derFile)) {
            writer.write(certificate.getEncoded());
        }
    }
}